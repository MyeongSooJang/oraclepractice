-- 04/07

-- 오라클이 제공하는 OBJECT
-- VIEW 객체에 대해 알아보기 -> STORE VIEW
-- SELECT 문의 결과(RESULT SET)을 하나의 테이블처럼 저장해 놓고 사용하는 것

-- CREATE VIEW 이름 
-- AS SELECT문 
-- RESOURCE ROLE에 포함되어 있지 않는다. 별도로 사용자 계정에 별도로 부여해야 함 -> CREATE VIEW

CREATE VIEW V_EMP
AS SELECT * 
FROM EMPLOYEE 
LEFT JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID;

GRANT CREATE VIEW TO BS;
-- BS에게 권한을 주어야 생성이 가능하다. --> DBA(관리자)로 실행

-- 생성한 VIEW는 테이블처럼 이용이 가능하다.

SELECT * 
FROM V_EMP;

SELECT *
FROM V_EMP
WHERE DEPT_TITLE = '총무부';

SELECT DEPT_TITLE AS 부서명, AVG(SALARY) AS 평균급여, COUNT(*) AS 인원수
FROM V_EMP
WHERE SALARY > 3000000
GROUP BY DEPT_TITLE;

-- VIEW 생성시 지정한 컬럼만 사용이 가능함.

CREATE OR REPLACE VIEW V_EMP
    AS SELECT EMP_NAME, DEPT_CODE, EMAIL, HIRE_DATE, DEPT_TITLE
            FROM EMPLOYEE
            LEPT JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
            JOIN JOB USING (JOB_CODE);

SELECT SALARY
FROM V_EMP;
-- 위에 VIEW에서는 나온 결과 값에서만 사용이 가능하다. SALARY는 없음!!!

-- 집합 연산으로 생성한 SELECT문 
CREATE VIEW V_AVG_SALARY
AS SELECT '부서' AS DIV, DEPT_CODE AS CODE, DEPT_TITLE AS TITLE, FLOOR(AVG(SALARY)) AS AVG_SAL, COUNT(*) AS COUNT
    FROM EMPLOYEE 
    LEFT JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
    GROUP BY DEPT_CODE,DEPT_TITLE

UNION
SELECT '직책', JOB_CODE, JOB_NAME, FLOOR(AVG(SALARY)), COUNT(*)
FROM EMPLOYEE 
JOIN JOB USING (JOB_CODE)
GROUP BY JOB_CODE, JOB_NAME;
    
SELECT * FROM V_AVG_SALARY;

SELECT * FROM V_AVG_SALARY WHERE COUNT >=3;

-- VIEW 테이블에서 사용한 컬럼명 지정하기

CREATE VIEW V_NAMED_VIEW (ENAME,DTITLE,INAME)
AS SELECT EMP_NAME, DEPT_TITLE, JOB_NAME
    FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
                            JOIN JOB USING (JOB_CODE);
                            
SELECT * FROM V_NAMED_VIEW;

-- SELECT EMP_NAME FROM V_NAMED_VIEW;
SELECT ENAME FROM V_NAMED_VIEW;

-- VIEW테이블에 DML 구문 사용해보기
-- INSERT문 사용해보기
-- 단일테이블을 가지고 있는  VIEW에 적용가능
-- SELECT문에 지정 되지 안은 컬럼에 NOT NULL이 없어야 한다.

CREATE OR REPLACE VIEW V_EMP_TEST
AS SELECT EMP_ID,EMP_NAME, EMP_NO, EMAIL, PHONE, JOB_CODE, SAL_LEVEL
FROM EMPLOYEE;

SELECT * FROM V_EMP_TEST;

INSERT INTO V_EMP_TEST VALUES ('999','으에에','991017-1124571','OSJ4004@NAVER.COM','01054220640','J2','S3');
-- > 들어가기는 하지만 이렇게 사용하지 않는다. 

SELECT * FROM EMPLOYEE; -- > 여기 들어간다.
--> 들어가는 정보만 빼고는 모두 NULL값으로 들어가게 된다. NOT NULL이면 불가능
--> 실제 테이블 말고 뷰에만 넣는다? 이건 불가능 왜냐? -> 실제 있는 테이블이 아니기 때문에
--> 그리고 VIEW가 JOIN 되어 있으면 사용이 불가능 하다고 알기 ( 규칙을 지키면 가능은 하긴하다.)
--> 원래 테이블에 값이 들어오게 되면 VIEW도 바뀌게 된다. (참조하기 때문에)

CREATE OR REPLACE VIEW V_EMP_TEST
AS SELECT EMP_NAME, EMP_NO, EMAIL, PHONE, JOB_CODE, SAL_LEVEL
FROM EMPLOYEE;

SELECT * FROM V_EMP_TEST;

INSERT INTO V_EMP_TEST VALUES ('으에에','991017-1124571','OSJ4004@NAVER.COM','01054220640','J2','S3');
-- > ID는 PRIMARY KEY 이면서 NOT NULL 이기 때문에 들어가지 X 

SELECT * FROM V_EMP_TEST;

CREATE OR REPLACE VIEW V_EMP_TEST
AS SELECT EMP_ID, EMP_NAME, EMP_NO, EMAIL, PHONE, JOB_CODE, SAL_LEVEL, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
    JOIN DEPARTMENT ON DEPT_ID = DEPT_CODE;

INSERT INTO V_EMP_TEST VALUES ('991','으에에','991017-1124571','OSJ4004@NAVER.COM','01054220640','J2','S3','10','TEST');
--> 조인 뷰에 의하여 하나 이상의 기본 테이블을 수정할 수 없습니다.
--> 분할해서 넣으면 되는 거 아닌가? -> 하지만 불가능 
-- 뷰테이블에서는 DML 구문을 사용하지 않는게 좋음!!!!!!!!!!!!!!!!!!!!!!!!!!

-- UPDATE문 실행하기
-- 실제 테이블에 존재하는 값을 변경이 가능

CREATE OR REPLACE VIEW V_EMP_UPDATE
AS SELECT EMP_NAME, SALARY, BONUS, DEPT_CODE, DEPT_TITLE, SALARY + 100 AS SUM_SALARY
FROM EMPLOYEE
JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID;

SELECT * 
FROM V_EMP_UPDATE;

UPDATE V_EMP_UPDATE SET SUM_SALARY = 10 -- ?
WHERE DEPT_CODE = 'D9';

SELECT * 
FROM EMPLOYEE;
-- > SALARY 가 10이 된것을 확인 할수 있다.
ROLLBACK;

-- DELETE문 사용하기
DELETE FROM V_EMP_UPDATE
WHERE EMP_NAME = '방명수';

-- VIEW 테이블 생성시 옵션 적용하기
--

CREATE VIEW V_EMP_UPDATE AS SELECT * FROM EMPLOYEE; --> 중복값이 존재하므로 에러

-- FORCE/ NOFORCE(DEFAULT 값) : 실제 테이블이 없어도 뷰를 생성할 수 있게 해주는 옵션

CREATE FORCE VIEW V_FORCETEST 
AS SELECT *
FROM TT;

SELECT * FROM V_FORCETEST;
CREATE TABLE TT(
    TT_NO NUMBER PRIMARY KEY,
    TT_CONTENT VARCHAR2(200)
);

-- WITH CHECK OPTION : VIEW 생성시 사용한 SELECT 문의 WHERE 절 컬럼값을 수점못하게 하는 옵션

CREATE OR REPLACE VIEW V_CHECK
AS SELECT EMP_NO, EMP_NAME, SALARY, DEPT_CODE
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5' WITH CHECK OPTION;

SELECT * FROM V_CHECK;
UPDATE V_CHECK SET DEPT_CODE = 'D6' WHERE SALARY <=2000000;
 ---> WITH CHECK OPTION 수정이 불가능
 UPDATE V_CHECK SET SALARY = SALARY + 100 WHERE SALARY <=2000000;
 -- 이거는 가능 SALARY 는 이거는 WITH CHECK OPTION 아니어서 수정 가능
ROLLBACK;

-- WITH READ ONLY : VIEW 테이블에서 수정이 불가능하게 설정하는 옵션
CREATE OR REPLACE VIEW V_CHECK
AS SELECT EMP_NO, EMP_NAME, SALARY, DEPT_CODE
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5' WITH READ ONLY;
 
UPDATE V_CHECK SET SALARY = SALARY + 100 WHERE SALARY <=2000000;
-- > 읽기 전용이므로 수정 X

SELECT * 
FROM V_CHECK
WHERE SALARY > 2000000;
-- 조회 가능!

SELECT * FROM V_AVG_SALARY WHERE DIV !='사원';
insert into EMPLOYEE (EMP_ID,EMP_NAME,EMP_NO,EMAIL,PHONE,DEPT_CODE,JOB_CODE,SAL_LEVEL,SALARY,BONUS,MANAGER_ID,HIRE_DATE, ENT_DATE,ENT_YN) 
values ('252','장명수','320808-2123341','go_dm@kh.or.kr',null,'D2','J2','S5',14480000,null,null,to_date('94/01/20','RR/MM/DD'),null,'N');


-- SEQUENCE 이용하기
-- 자동으로 번호를 생성해주는 객체
-- PK값으로 많이 이용
-- CREATE SEQUENCE 시퀀스명 （옵션 ） : 
-- 옵션은 모두 DEFAULT 값을 갖고 있어서 설정하지 않아도 된다

CREATE SEQUENCE SEQ_BASIC;

-- 옵션이 없이 생성하면 1부터 1씩증가 시키면서 번호를 생성해줌
-- SEQUENCE에서 번호를 가져오려면 SEQ_BASICNEXTVAL예약어를 이용해서 가져옴

SELECT SEQ_BASIC.NEXTVAL FROM DUAL;

CREATE TABLE SEQ_BOARD(
    BOARD_NO NUMBER PRIMARY KEY,
    BOARD_TITLE VARCHAR2(200) NOT NULL,
    BOARD_CONTENT VARCHAR2(4000)
);

INSERT INTO SEQ_BOARD VALUES (SEQ_BASIC.NEXTVAL,'월요일힘내세요','곧 있으면 점심');
INSERT INTO SEQ_BOARD VALUES (SEQ_BASIC.NEXTVAL,'점심메뉴는','돈까스');
SELECT * FROM SEQ_BOARD;
DELETE FROM SEQ_BOARD WHERE BOARD_NO = 16;
-- 이름과 같은 것! 그냥 17이 숫자가 아니라 17이라는 이름

-- 현재 부여된 번호 확인하기
SELECT SEQ_BASIC.CURRVAL FROM DUAL;

CREATE TABLE UPLOAD_FILE (
    FILE_NO  NUMBER PRIMARY KEY,
    FILE_NAME VARCHAR2(200) NOT NULL,
    BOARD_REF NUMBER CONSTRAINT FK_FILE_BOARREF REFERENCES SEQ_BOARD(BOARD_NO)
    );

-- 게시글 등록
INSERT INTO SEQ_BOARD VALUES(SEQ_BASIC.NEXTVAL,'첨푸파일과 함께','호호호');
SELECT SEQ_BASIC.CURRVAL FROM DUAL;
INSERT INTO UPLOAD_FILE VALUES(SEQ.FILE.NEXTVAL,'지브리풍.JPG',?);

-- PK값을 문자열로 처리하기
-- 상품번호, 락커번호 
SELECT 'P_' || SEQ_BASIC.NEXTVAL FROM DUAL;
SELECT 'P_' || LPAD(SEQ_BASIC.NEXTVAL,5,'0') FROM DUAL;

-- SEQUENCE 옵션 적용하기
-- START WITH : 번호 시작 값 설정 DEFAULT 1
-- INCREMENT BY : 증가값 설정 DEFAULT 1
-- MAX VALUE : 최댓값
-- MIN VALUE :  최솟값
-- CYCLE/NOCYCLE : 최댓값, 최소값에 도달했을때 최소,최대값으로 순환되는 설정 DEFAULT NOCYCLE
-- CACHE/NOCACHE : 미리 번호를 생성해 놓는 것 DEFAULT 20


SELECT * FROM USER_SEQUENCES;

CREATE SEQUENCE SEQ_BASIC2 
START WITH 100
INCREMENT BY 10;

SELECT SEQ_BASIC2.NEXTVAL FROM DUAL;

CREATE SEQUENCE SEQ_BASIC3
START WITH 100
INCREMENT BY -10
MAXVALUE 100
MINVALUE 1;

SELECT SEQ_BASIC3.NEXTVAL FROM DUAL;

CREATE SEQUENCE SEQ_BASIC4
START WITH 100
INCREMENT BY -10
MAXVALUE 100
MINVALUE 1
CYCLE
NOCACHE;

SELECT SEQ_BASIC4.NEXTVAL FROM DUAL;

CREATE SEQUENCE SEQ_BASIC5NOCACHE;
SELECT * FROM USER_SEQUENCES;

-- INDEX 설정하기
CREATE TABLE EMP(
    EMP_ID NUMBER PRIMARY KEY,
    EMP_NAME VARCHAR2(100),
    DEPARTMENT VARCHAR2(50),
    SALARY NUMBER,
    HIRE_DATE DATE
);

SELECT * FROM EMP;

BEGIN
    FOR I IN 1..100000 LOOP
        INSERT INTO EMP VALUES(
        I,
        'EMP'||I,
        CASE MOD(I,5)
            WHEN 0 THEN '영업'
            WHEN 1 THEN '개발'
            WHEN 2 THEN '총무'
            WHEN 3 THEN '인사'
            ELSE '임원'
        END,
        TRUNC(DBMS_RANDOM.VALUE(2000000,6000000)),
        SYSDATE-DBMS_RANDOM.VALUE(0,1000)
    );
  END LOOP
  COMMIT;
END;
/
SELECT * FROM EMP
WHERE EMP_NAME ='TEST';


SELECT * FROM EMP
WHERE HIRE_DATE BETWEEN '24/01/01' AND '24/12/31';

CREATE INDEX IDX_EMP_EMP_NAME ON EMP(EMP_NAME);
DROP INDEX IDX_EMP_EMP_NAME;

EXPLAIN PLAN FOR
    SELECT * FROM EMP
    WHERE HIRE_DATE BETWEEN '24/01/01' AND '24/12/31';
    
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- PL/SQL구문
-- PL/SQL구문을 사용하는 방법
-- 1. 익명블록을 사용하는 방법
-- 2. OBJECT(PROCEDURE, FUNCTION, TRIGGER)에서 사용하는 방법

-- 익명블록사용하기
-- [DECLARE
--    변수선언]
-- BEGIN
--  실행할 로직(IF, FOR WHILE, LOOP, 연산처리, SELECT문, DML구문)
-- END;
-- / -->끝

SET SERVEROUTPUT ON;

BEGIN
    DBMS_OUTPUT.PUT_LINE('HELLO ORACLE');
END;
/

DECLARE
    NAME VARCHAR2(10);
    AGE NUMBER:=19;
    BIRTHDAY DATE;
BEGIN
    NAME := '유병승';
    BIRTHDAY:='00/09/03';
    DBMS_OUTPUT.PUT_LINE(NAME||' '||AGE||' '||BIRTHDAY);
END;
/

-- 실행부에서 SELECT문 이용하기 
-- 반드시 결과를 저장하는 구문까지 작성을 해야함.
-- SELECT * FROM 
-- SELECT 컬럼명,컬럼명2 
--   INTO 변수명, 변수명2
-- FROM 테이블명 WHERE GROUP BY ...
DECLARE
    V_EMP_NAME VARCHAR2(50);
    V_SALARY NUMBER;
    V_EMAIL VARCHAR2(50);
BEGIN
    SELECT EMP_NAME,SALARY,EMAIL
        INTO V_EMP_NAME,V_SALARY,V_EMAIL
    FROM EMPLOYEE
    WHERE EMP_ID='200';
    DBMS_OUTPUT.PUT_LINE(V_EMP_NAME||' '||V_SALARY||' '||V_EMAIL);
END;
/

-- 참조해서 자료형 가져오기
-- 참조형타입 : 테이블.컬럼명%TYPE
DECLARE
    V_EMPID EMPLOYEE.EMP_ID%TYPE;
    V_SALARY EMPLOYEE.SALARY%TYPE;
BEGIN
    SELECT EMP_ID,SALARY
        INTO V_EMPID, V_SALARY
    FROM EMPLOYEE 
    WHERE EMP_NAME='&사원명';
    
    DBMS_OUTPUT.PUT_LINE(V_EMPID||' '||V_SALARY);
END;
/

-- 한개 ROW전체를 저장하는 타입 이용하기
-- ROWTYPE -> 테이블명%ROWTYPE
DECLARE
    V_EMP EMPLOYEE%ROWTYPE;
    V_DEPT DEPARTMENT%ROWTYPE;
BEGIN
    SELECT *
        INTO V_EMP
    FROM EMPLOYEE
    WHERE EMP_ID='&사원번호';
    
    DBMS_OUTPUT.PUT_LINE(V_EMP.EMP_ID||' '||V_EMP.SALARY||' '||V_EMP.DEPT_CODE||' '||V_EMP.EMP_NAME);
    
    SELECT *
        INTO V_DEPT
    FROM DEPARTMENT
    WHERE DEPT_ID=V_EMP.DEPT_CODE;
    
    DBMS_OUTPUT.PUT_LINE(V_DEPT.DEPT_TITLE||' '||V_DEPT.LOCATION_ID);
        
END;
/

-- 타입을 생성해서 이용
-- RECORD -> 자바의 클래스와 유사
DECLARE
    TYPE MYRECORD IS RECORD(
        EMPNAME EMPLOYEE.EMP_NAME%TYPE,
        SALARY EMPLOYEE.SALARY%TYPE,
        DEPTTITLE DEPARTMENT.DEPT_TITLE%TYPE,
        JOBNAME JOB.JOB_NAME%TYPE
    );
    
    MYDATA MYRECORD;
BEGIN
    SELECT EMP_NAME, SALARY,DEPT_TITLE,JOB_NAME
     INTO MYDATA
    FROM EMPLOYEE 
        JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
        JOIN JOB USING(JOB_CODE)
    WHERE EMP_ID='&사원번호';
    DBMS_OUTPUT.PUT_LINE(MYDATA.EMPNAME||' '||MYDATA.SALARY||' '||MYDATA.DEPTTITLE||' '||MYDATA.JOBNAME);
END;
/

-- 테이블 타입 -> 자바의 배열과 유사

DECLARE
    TYPE EMPNAME_TABLE IS TABLE OF EMPLOYEE.EMP_NAME%TYPE
    INDEX BY BINARY_INTEGER;
    
    EMPNAMES EMPNAME_TABLE;
    I BINARY_INTEGER:=1;
BEGIN
    -- 인덱스 번호로 접근해서 처리, 인덱스번호는 1부터시작
    EMPNAMES(1):='양지혁';
    EMPNAMES(2):='박서영';
    EMPNAMES(3):='박세웅';
    EMPNAMES(4):='황민익';
    
    DBMS_OUTPUT.PUT_LINE(EMPNAMES(1));
    DBMS_OUTPUT.PUT_LINE(EMPNAMES(2));
    DBMS_OUTPUT.PUT_LINE(EMPNAMES(3));
    DBMS_OUTPUT.PUT_LINE(EMPNAMES(4));
    
    FOR E IN (SELECT * FROM EMPLOYEE) LOOP
        EMPNAMES(I) := E.EMP_NAME;
        I:=I+1;
    END LOOP;
    
    FOR J IN 1..I-1 LOOP
        DBMS_OUTPUT.PUT_LINE(EMPNAMES(J));
    END LOOP;
END;
/

-- 조건문 사용하기
-- IF 조건문
--  THEN (TRUE일때)
-- END IF

DECLARE
    V_SALARY EMPLOYEE.SALARY%TYPE;
BEGIN
    SELECT SALARY
        INTO V_SALARY
    FROM EMPLOYEE
    WHERE EMP_ID = '&사원번호';
    
    IF V_SALARY >2000000
        THEN DBMS_OUTPUT.PUT_LINE('우와 200만원보다 많이 받아! 대박~');
        INSERT INTO HISTORY_SAL VALUES(V_SALARY,SYSDATE);
        COMMIT;
    END IF;
END;
/

SELECT * FROM HISTORY_SAL;
CREATE TABLE HISTORY_SAL(
    SALARY NUMBER,
    INSERT_DATE DATE
);


-- IF 조건문 THEN 실행문 ELSE 실행문 END IF

DECLARE
    V_SALARY EMPLOYEE.SALARY%TYPE;
BEGIN
    SELECT SALARY
    INTO V_SALARY
    FROM EMPLOYEE
    WHERE EMP_ID ='&사원번호';
    
    IF V_SALARY > 4000000
        THEN DBMS_OUTPUT.PUT_LINE('오오오오!!!!!!!!!!');
    ELSE DBMS_OUTPUT.PUT_LINE('......');
    END IF;
END;
/
SET SERVEROUTPUT ON;
-- 350만원 이상 급여를 받으면 HIGHT_SAL테이블에 저장 아니면 LOW_SAL테이블에 저장
-- 사원번호, 사원명, 급여, 고용일


DECLARE
    
    V_EMP_ID EMPLOYEE.EMP_ID%TYPE;
    V_EMP_NAME EMPLOYEE.EMP_NAME%TYPE;
    V_SALARY EMPLOYEE.SALARY%TYPE;
    V_HIRE_DATE EMPLOYEE.HIRE_DATE%TYPE;
BEGIN
    SELECT EMP_ID, EMP_NAME, SALARY, HIRE_DATE
    INTO V_EMP_ID, V_EMP_NAME, V_SALARY, V_HIRE_DATE
    FROM EMPLOYEE
    WHERE EMP_ID='&사원번호';
    
    IF V_SALARY >=3500000
        THEN 
        INSERT INTO HIGH_SAL (EMP_ID, EMP_NAME, SALARY, HIRE_DATE)
        VALUES(V_EMP_ID, V_EMP_NAME, V_SALARY, V_HIRE_DATE);
    ELSE
        INSERT INTO LOW_SAL (EMP_ID, EMP_NAME, SALARY, HIRE_DATE)
        VALUES(V_EMP_ID, V_EMP_NAME, V_SALARY, V_HIRE_DATE);
    
    END IF;
    COMMIT;
END;
/
--
SELECT * FROM HIGH_SAL;
SELECT * FROM LOW_SAL;
SELECT * FROM EMPLOYEE;





-- 테이블을 만들어야 해요
SELECT * FROM HIGH_SAL;

CREATE TABLE HIGH_SAL(
    EMP_ID NUMBER,
    EMP_NAME VARCHAR2(100),
    SALARY NUMBER,
    HIRE_DATE DATE
);

CREATE TABLE LOW_SAL(
    EMP_ID NUMBER,
    EMP_NAME VARCHAR2(100),
    SALARY NUMBER,
    HIRE_DATE DATE
);


-------------------- 답


DECLARE
    EMP EMPLOYEE%ROWTYPE;
BEGIN
    SELECT *
    INTO EMP
    FROM EMPLOYEE
    WHERE EMP_ID='&사원번호';
    
    IF  EMP.SALARY>3000000 
        THEN INSERT INTO HIGH_SAL VALUES(EMP.EMP_ID,EMP.EMP_NAME,EMP.SALARY,EMP.HIRE_DATE);
    ELSE  INSERT INTO LOW_SAL VALUES(EMP.EMP_ID,EMP.EMP_NAME,EMP.SALARY,EMP.HIRE_DATE);
    END IF;
END;
/
CREATE TABLE HIGH_SAL
AS SELECT EMP_ID,EMP_NAME,SALARY,HIRE_DATE FROM EMPLOYEE WHERE 1=0;
CREATE TABLE LOW_SAL
AS SELECT EMP_ID,EMP_NAME,SALARY,HIRE_DATE FROM EMPLOYEE WHERE 1=0;
SELECT * FROM HIGH_SAL;
SELECT * FROM LOW_SAL;
--------------------------------------------------------------------------------------------



-- IF ELSIF ELSIF ELSE 구문 이용
-- 사원을 대표(J1), 임원(J2,J3,J4), 평사원(J5,J6)
-- 각 직책을 출력해주는 기능

DECLARE
    V_EMP_ID EMPLOYEE.EMP_ID%TYPE;
    V_JOB_CODE EMPLOYEE.JOB_CODE%TYPE;
    MSG VARCHAR2(50);
BEGIN
    SELECT JOB_CODE
    INTO V_JOB_CODE
    FROM EMPLOYEE
    WHERE EMP_ID='&사번';
    
    IF V_JOB_CODE ='J1'
        THEN MSG:='대표';
    ELSIF V_JOB_CODE IN ('J2','J3','J4')
        THEN MSG:='임원';
    ELSE MSG:='평사원';
    END IF;
    
    DBMS_OUTPUT.PUT_LINE(MSG);
END;
/

-- CASE문 사용하기
-- CASE
--      WHEN 조건문 THEN 실행문
--      WHEN 조건문 THEN 실행문
--      WHEN 조건문 THEN 실행문
--      ELSE 실행문
-- END CASE;

DECLARE
    NUM NUMBER;
BEGIN
    NUM :='&수';
    CASE
        WHEN NUM >10
            THEN DBMS_OUTPUT.PUT_LINE('10초과');
        WHEN NUM>5
            THEN DBMS_OUTPUT.PUT_LINE('5~10');
        ELSE DBMS_OUTPUT.PUT_LINE('5이하');
    END CASE;
END;
/

-- 반복문 
-- LOOP예약어를 사용해서 실행
-- 1~100까지 출력하기

DECLARE
    NUM NUMBER :=1;
    RNDNUM NUMBER;
BEGIN
    LOOP
    DBMS_OUTPUT.PUT_LINE(NUM);
    RNDNUM := FLOOR(DBMS_RANDOM.VALUE(1, 200));
    INSERT INTO SEQ_BOARD 
    VALUES(SEQ_BASIC.NEXTVAL, 'TEST' || RNDNUM,RNDNUM ||' '||NUM);
    
    IF NUM =100
        THEN EXIT;
    END IF;
    NUM:=NUM+1;
    END LOOP;
END;
/

-- WHILE문 이용하기
-- WHILE 조건문 LOOP
-- 실행구문
-- END LOOP;
DECLARE 
    NUM NUMBER := 1;
BEGIN
    WHILE NUM <= 10 LOOP
        DBMS_OUTPUT.PUT_LINE(NUM);
        NUM := NUM +1;
    END LOOP;
END;
/

-- FOR문 이용하기
BEGIN
    FOR I IN 1..10 LOOP
        DBMS_OUTPUT.PUT_LINE(I);
    END LOOP;
END;
/
-- 범위만큼 반복하는 반복문 -> 기본 FOR문
-- SELECT문을 이용한 반복문 -> FOR EACH문
BEGIN 
    FOR EMP IN (SELECT * FROM EMPLOYEE) 
    LOOP
    IF EMP.SALARY >= 3500000 THEN 
        INSERT INTO HIGH_SAL (EMP_ID,EMP_NAME,SALARY,HIRE_DATE)
        VALUES(EMP.EMP_ID,EMP.EMP_NAME, EMP.SALARY, EMP.HIRE_DATE);
    ELSE 
        INSERT INTO LOW_SAL(EMP_ID,EMP_NAME,SALARY,HIRE_DATE) 
        VALUES(EMP.EMP_ID,EMP.EMP_NAME, EMP.SALARY, EMP.HIRE_DATE);
    END IF;
    END LOOP;
END;
/
SELECT * FROM HIGH_SAL;
SELECT * FROM LOW_SAL;


-- 객체로 저장해서 사용하기
-- PROCEDURE, FUNCTION 생성하기

-- PROCEDURE 생성하기
-- CREATE [ OR REPLACE] PROCEDURE 프로시저명[0]
-- IS 
-- [변수선언]
-- BEGIN
-- END;
-- / 

-- 프로시저 호출하기
-- EXEC 프로시저명():
-- CALL(프로시저명)
DROP TABLE EMP_DEL;
CREATE TABLE EMP_DEL
AS SELECT * FROM EMPLOYEE;
SELECT * FROM EMP_DEL;


CREATE OR REPLACE PROCEDURE EMP_DEL_PRO
IS
BEGIN
    DELETE FROM EMP_DEL;
    COMMIT;
END;
/
EXEC EMP_DEL_PRO;

-- EMP_DEL_PRO를 호출하면
-- JOB_CODE가 J1,J2,J3인 사원을 EMP_TEMP 테이블에 옮기고, 사원 데이터 삭제
DROP TABLE EMP_DEL;
CREATE TABLE EMP_DEL
AS SELECT * FROM EMPLOYEE;
SELECT * FROM EMP_DEL;

SELECT * FROM EMP_TEMP;

CREATE TABLE EMP_TEMP
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, JOB_CODE, SALARY 
FROM EMPLOYEE
WHERE 1 = 0;

CREATE OR REPLACE PROCEDURE EMP_DEL_PRO
IS
BEGIN
    FOR E IN (SELECT * FROM EMP_DEL) LOOP
    IF E.JOB_CODE IN('J1','J2','J3')
    
    
        THEN INSERT
                INTO EMP_TEMP(EMP_ID, EMP_NAME, DEPT_CODE, JOB_CODE, SALARY)
                VALUES(E.EMP_ID, E.EMP_NAME, E.DEPT_CODE, E.JOB_CODE, E.SALARY);
    END IF;
    END LOOP;
    DELETE FROM EMP_DEL;
    COMMIT;
END;
/
-->  프로시저(메소드)를 만든 것
EXEC EMP_DEL_PRO;
-- > 프로시저(메소드)를 실행시키는 것
SELECT * FROM EMP_TEMP;







