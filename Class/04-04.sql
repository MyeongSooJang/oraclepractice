--------------------------------------------------------04 - 04 ----------------------------------------------------------------------

-- DEFAULT 값 설정하기 ! 

CREATE TABLE CONS_DEFAULT(
    TEST_NO NUMBER PRIMARY KEY,
    TEST_DATA VARCHAR(50) DEFAULT  '기본값',
    TEST_DATE DATE DEFAULT SYSDATE
);

INSERT INTO CONS_DEFAULT VALUES(1, '내가넣은값','25/02/27');
SELECT * FROM CONS_DEFAULT;
INSERT INTO CONS_DEFAULT VALUES(2, DEFAULT,DEFAULT);
INSERT INTO CONS_DEFAULT (TEST_NO) VALUES(3);

DROP TABLE CONS_DEFAULT2;
CREATE TABLE CONS_DEFAULT2(
    TEST_NO NUMBER PRIMARY KEY,
    TEST_DATA VARCHAR(50) ,
    TEST_DATE DATE DEFAULT SYSDATE NOT NULL
);

INSERT INTO CONS_DEFAULT2(TEST_NO,TEST_DATE) VALUES(1,'25/09/03');
SELECT * FROM CONS_DEFAULT2;
INSERT INTO CONS_DEFAULT2(TEST_NO) VALUES(2);

-- 제약조건을 설정시 제약조건명을 설정하기
CREATE TABLE CONS_NAMESET(
    MEMBER_NO NUMBER CONSTRAINT PK_NAMESET_MEMBER_NO PRIMARY KEY,
    MEMBER_ID VARCHAR2(20) CONSTRAINT UQ_NAMESET_ID UNIQUE CONSTRAINT NN_NAMESET_ID NOT NULL  
--    CONSTRAINT FK_TEST FOREIGN KEY (MEMBER_NO) REFERENCES MEMBER_PK(MEMBER_NO)
);

INSERT INTO CONS_NAMESET VALUES(1,'ADMIN');
INSERT INTO CONS_NAMESET VALUES(2,'ADMIN');

-- 설정된 제약조건을 조회하기
-- USER_CONSTRAINT, USER_CONS_COLUMNS테이블 제공함
SELECT * FROM USER_CONSTRAINTS;
SELECT * FROM USER_CONS_COLUMNS;
SELECT CONSTRAINT_NAME, C.TABLE_NAME, COLUMN_NAME,C.CONSTRAINT_TYPE ,SEARCH_CONDITION
FROM USER_CONSTRAINTS C JOIN USER_CONS_COLUMNS  USING(CONSTRAINT_NAME)
WHERE C.TABLE_NAME = 'EMPLOYEE';

-- 컬럼에 코멘트 설정하기
COMMENT ON COLUMN CONS_MEMBER_PK.MEMBER_NO IS '회원번호 SEQ_NO시퀀스로 자동부여';

SELECT * FROM USER_COL_COMMENTS
WHERE TABLE_NAME = 'CONS_MEMBER_PK';
-- 검색해서 사용하는 방법 

-- 기존 테이블에 있는 데이터를 복사해서 새로운 테이블 만들기
-- 서브쿼리이용
CREATE TABLE COPY_TEST
AS SELECT * FROM EMPLOYEE;

SELECT * FROM COPY_TEST;

CREATE TABLE COPY_TEST2
AS SELECT E.*, DECODE(SUBSTR(EMP_NO,8,1),'1','M','2','F','3','M','4','F') AS
GENDER  FROM EMPLOYEE E;

-- AS해서 COPY해서 만들게 되면 제약조건 중 NOT NULL만 남고 PRIMARY KEY, UNIQUE
-- 는 없어지게 된다.

SELECT * FROM COPY_TEST2 WHERE GENDER = 'M';

-- 테이블의 구조만 복사하기

CREATE TABLE COPY_TABLE3
AS SELECT EMP_NAME, EMP_NO, SALARY, BONUS FROM EMPLOYEE
WHERE 1 =0 ;
-- 조건이 무조건 FALSE라서 틀만 복사해서 온다.

SELECT *FROM COPY_TEST3;

--TEST_MEMBER 테이블
--MEMBER_CODE(NUMBER) - 기본키                        -- 회원전용코드 
--MEMBER_ID (varchar2(20) ) - 중복금지, NULL값 허용금지    -- 회원 아이디
--MEMBER_PWD (char(20)) - NULL 값 허용금지                    -- 회원 비밀번호
--MEMBER_NAME(nchar(10)) - 기본값 '아무개'                -- 회원 이름
--MEMBER_ADDR (char(50)) - NULL값 허용금지                    -- 회원 거주지
--GENDER (varchar2(5)) - '남' 혹은 '여'로만 입력 가능                -- 성별
--PHONE(varchar2(20)) - NULL 값 허용금지                     -- 회원 연락처
--HEIGHT(NUMBER(5,2) - 130이상의 값만 입력가능           -- 회원키
--TYPE_NO NUMBER - BOARD_TYPE테이블 TYPE_NO값을 참조 -- 보드타입참조

--BOARD_TYPE테이블
--TYPE_NO NUMBER - 기본키
--TYPE_TITLE VARCHAR2(10)

CREATE TABLE TEST_MEMBER(
    MEMBER_CODE NUMBER PRIMARY KEY,
    MEMBER_ID VARCHAR2(20) UNIQUE NOT NULL,
    MEMBER_PWD CHAR(20) NOT NULL,
    MEMBER_NAME NCHAR(10) DEFAULT '아무개',
    MEMBER_ADDR CHAR(50) NOT NULL,
    GENDER VARCHAR2(5) CHECK(GENDER IN ('남','여')),
    PHONE VARCHAR2(20) NOT NULL,
    HEIGHT NUMBER(5,2) CHECK(HEIGHT >= 130),
    TYPE_NO NUMBER REFERENCES CONS_BOARD(BOARD_NO)
);
-- 열 검사제약은 다른열을 참조할 수 없습니다?
-- CHECK 할때에는 다른열을 참조가 안된다.

CREATE TABLE BOARD_TYPE(
TYPE_NO NUMBER PRIMARY KEY,
TYPE_TITTLE VARCHAR2(10)
);

SELECT * FROM TEST_MEMBER;
SELECT * FROM BOARD_TYPE;

INSERT INTO TEST_MEMBER VALUES (1, '히히히', '후후후', '홍길동','한국','남','010-123-456',138.5);

-- DML 구문활용하기
-- ROW(DATA)를 테이블에 추가, 수정, 삭제하는 명령어
-- INSERT : 테이블 새로운 데이터(ROW)를 추가할때 사용하는 명령어
-- 1. 저장할 컬럼을 지정해서 저장하는 방법
-- INSERT INTO 테이블명 (컬럼명,컬럼명2,컬럼명3...  ) VALUES(값1,값2,값3)
-- 지정하지 않은 컬럼은 기본적으로 NULL값으로 저장합니다. -> NOT NULL 제약조건이 설정되어 있으면 저장이 안됨.
-- 단 DEFAULT 제약조건이 있으면 DEFAULT 값으로 저장함.
-- 2. 전체 컬럼을 저장하는 방법
-- INSERT INTO 테이블명) VALUES (전체 컬럼에 대입할 값)
-- 값이 갯수가 부족하거나 많으면 에러가 발생하게 된다.

CREATE TABLE TEMP_DEPT AS SELECT* FROM DEPARTMENT WHERE 1=0;

SELECT * FROM TEMP_DEPT;
--전체 컬럼에 값 대입하기
INSERT INTO TEMP_DEPT VALUES('D1','D8학부','L3');
INSERT INTO TEMP_DEPT VALUES('D1','D8학부','L3',123);
INSERT INTO TEMP_DEPT VALUES('D2');

-- 컬럼수에 맞춰서 다 넣어주어야 한다.

-- 컬럼 지정해서 값 대입하기
INSERT INTO TEMP_DEPT (DEPT_ID ,LOCATION_ID) VALUES('D2','L2');
SELECT * FROM TEMP_DEPT;
INSERT INTO TEST_DEPT (DEPT_TITLE) VALUES('자바학부');

DESC TEMP_DEPT;

-- SELECT문을 이용해서 값 저장하기
-- 다른 테이블에 있는 값을 복사해서 저장

CREATE TABLE INSERT_SUBQUERY
AS SELECT EMP_ID,EMP_NAME,DEPT_TITLE,HIRE_DATE
FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID WHERE 1=0;
SELECT * FROM INSERT_SUBQUERY;

INSERT INTO INSERT_SUBQUERY(
    SELECT EMP_ID,EMP_NAME,DEPT_TITLE,HIRE_DATE
    FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID WHERE SALARY >= 3000000
    );
    
INSERT INTO INSERT_SUBQUERY(
SELECT DEPT_ID,DEPT_TITLE,'없어',SYSDATE
FROM DEPARTMENT
);

-- 컬럼을 지정해서 저장하기
INSERT INTO INSERT_SUBQUERY(EMP_ID,EMP_NAME)(
    SELECT JOB_CODE,JOB_NAME FROM JOB
);

SELECT * FROM INSERT_SUBQUERY;

-- INSERT ALL
-- 한개의 SELECT문의 데이터를 다수의 테이블에 저장하는 명령어
-- INSERT ALL
-- INTO 테이블명 VALUES(컬럼명,컬럼명2,컬럼명3....)
-- INTO 테이블명2 VALUES(컬럼명,컬럼명2,컬럼명3....)
-- SELECT 절

-- INSERT ALL
-- WHEN 조건문
--      THEN
--              INTO 테이블명  VALUES(컬럼명,컬럼명2,컬럼명3....)
-- WHEN 조건문
--      THEN
--              INTO 테이블명  VALUES(컬럼명,컬럼명2,컬럼명3....)
-- SELECT 절

CREATE TABLE EMP_HIRE_DATE
AS SELECT EMP_ID,EMP_NAME, HIRE_DATE FROM EMPLOYEE WHERE 1=0;

CREATE TABLE EMP_MANAGER
AS SELECT EMP_ID,EMP_NAME, MANAGER_ID FROM EMPLOYEE WHERE 1=0;

SELECT * FROM EMP_HIRE_DATE;
SELECT * FROM EMP_MANAGER;

>>?
INSERT ALL
  INTO EMP_HIRE_DATE (EMP_ID, EMP_NAME, HIRE_DATE) 
    VALUES (EMP_ID, EMP_NAME, HIRE_DATE)
  INTO EMP_HIRE_DATE (EMP_ID, EMP_NAME, MANAGER_ID)
    VALUES (EMP_ID, EMP_NAME, MANAGER_ID)
SELECT EMP_ID, EMP_NAME, HIRE_DATE, MANAGER_ID FROM EMPLOYEE;

-- 조건에 따라 데이터를 분류하여 각 테이블에 저장하기
-- OLD, NEW
-- 입사월이 '00/01/01'
DROP TABLE OLD_EMP;
DROP TABLE NEW_EMP;
CREATE TABLE OLD_EMP
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE FROM EMPLOYEE WHERE 1=0;
CREATE TABLE NEW_EMP
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE FROM EMPLOYEE WHERE 1=0;

INSERT ALL
    WHEN HIRE_DATE<TO_DATE('00/01/01','YY/MM/DD')
        THEN INTO OLD_EMP VALUES(EMP_ID, EMP_NAME, HIRE_DATE)
    WHEN HIRE_DATE > TO_DATE('00/01/01','YY/MM/DD')
         THEN INTO NEW_EMP VALUES(EMP_ID, EMP_NAME, HIRE_DATE)
SELECT * FROM EMPLOYEE;

SELECT * FROM OLD_EMP;
SELECT * FROM NEW_EMP;

-- UPDATE 문 이용하기
-- UPDATE 테이블명 SET 컬럼명 = 값,[컬럼명2 =값2, 컬럼명3 = 값3...] [WHERE 조건]

CREATE TABLE UPDATE_TEST_EMP AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, JOB_CODE , SALARY, BONUS FROM EMPLOYEE;
SELECT * FROM UPDATE_TEST_EMP;

-- 하동운의 부서를 D3로 변경하기

UPDATE UPDATE_TEST_EMP SET DEPT_CODE = 'D3' WHERE EMP_NAME ='하동운';

-- BONUS를 받지 않는 사원의 BONUS를 0.05
UPDATE UPDATE_TEST_EMP SET BONUS=0.05 WHERE BONUS IS NULL;

-- D5부서의 사원 급여를 3000000, 보너스를 0.5로 변경하기

UPDATE UPDATE_TEST_EMP SET SALARY = 3000000  WHERE DEPT_CODE = 'D5';
UPDATE UPDATE_TEST_EMP SET BONUS = 0.5  WHERE DEPT_CODE = 'D5';

UPDATE UPDATE_TEST_EMP SET SALARY = 3000000, BONUS = 0.5 WHERE DEPT_CODE = 'D5';
-- AND가 아니라 쉼표를 사용해서 한다.

SELECT * FROM UPDATE_TEST_EMP ORDER BY DEPT_CODE ;

-- 단일행함수, 기본값을 가져와 사용할 수 있음
-- 직책이 J7인 사원의 급여를 + 500000 인상

UPDATE UPDATE_TEST_EMP SET SALARY = SALARY + 500000 WHERE JOB_CODE ='J7';
SELECT * FROM UPDATE_TEST_EMP WHERE JOB_CODE='J7';

-- 수정사항을 원래대로 돌림
ROLLBACK;

-- 모든 사원의 보너스를 0.1인상
SELECT * FROM  UPDATE_TEST_EMP;
UPDATE  UPDATE_TEST_EMP SET BONUS = NVL(BONUS,0)+0.1;
SELECT * FROM EMPLOYEE;

SELECT * FROM COPY_TEST;
UPDATE COPY_TEST SET EMAIL = REPLACE(EMAIL,'BS','bs');
ROLLBACK;
UPDATE COPY_TEST
SET EMAIL = SUBSTR(EMAIL, 1, INSTR(EMAIL, '@') - 1) || LOWER(SUBSTR(EMAIL, INSTR(EMAIL, '@') + 1));


-- UPDATE 서브 커리 사용하기
UPDATE UPDATE_TEST_EMP
SET SALARY = (SELECT SALARY FROM EMPLOYEE WHERE EMP_NAME = '선동일'),
    BONUS = (SELECT BONUS FROM EMPLOYEE WHERE EMP_NAME = '선동일')
WHERE DEPT_CODE = 'D9';

SELECT * FROM UPDATE_TEST_EMP;

-- MERGE : 두개의 테이블을 한개로 합치는 명령어 
-- MERGE INTO 테이블 : USING 테이블 (합칠테이블) ON 조건
-- WHEN MATCHED / NOT MATCHED THEN 실행할 DML 구문을 작성 (INSERT,UPDATE)

CREATE TABLE EMP_M1
AS SELECT * FROM EMPLOYEE ;
CREATE TABLE EMP_M2
AS SELECT * FROM EMPLOYEE WHERE JOB_CODE = 'J4';
SELECT * FROM EMP_M1;
SELECT * FROM EMP_M2;
UPDATE EMP_M2 SET SALARY =10, BONUS = 0.00001;
INSERT INTO EMP_M2 VALUES(999,'장명수','990427-1234567','MMSGOD0427@NAVER.COM','01083109608','D2','J7','S3',10,0.0002,NULL,SYSDATE,DEFAULT,DEFAULT);

MERGE INTO EMP_M1 USING EMP_M2 ON (EMP_M1.EMP_ID = EMP_M2.EMP_ID)
    WHEN MATCHED THEN
        UPDATE SET EMP_M1.SALARY = EMP_M2.SALARY, EMP_M1.BONUS = EMP_M2.BONUS
    WHEN NOT MATCHED THEN 
        INSERT VALUES(
                EMP_M2.EMP_ID,EMP_M2.EMP_NAME,EMP_M2.EMP_NO,EMP_M2.EMAIL,EMP_M2.PHONE,
                EMP_M2.DEPT_CODE,EMP_M2.JOB_CODE,EMP_M2.SAL_LEVEL,EMP_M2.SALARY,EMP_M2.BONUS,
                EMP_M2.MANAGER_ID,EMP_M2.HIRE_DATE,EMP_M2.ENT_DATE,EMP_M2.ENT_YN
    );



SELECT * FROM EMP_M1;

-- DELETE 이용하기
-- ROW를 삭제하는 명령어 
-- DELETE FROM 테이블명 WHERE 조건문
-- EMP_M1 테이블에서 J4 사원을 삭제하기

DELETE FROM EMP_M1 WHERE JOB_CODE = 'J4';
SELECT * FROM EMP_M1;

DELETE FROM EMP_M1 WHERE LENGTH(EMAIL) >=16;

-- INSERT,DELETE,UPDATE --> ROW를 수정하는 구문을 실행
-- 트랜젝션으로 묶음..
ROLLBACK;

DELETE FROM EMP_M1;

-- TRUNCATE
-- 트랙젝션 범위에 포함이 되지 않음
TRUNCATE TABLE EMP_M2;
SELECT * FROM EMP_M2;
ROLLBACK;

-- DDL ALTER와 DROP 명령어 이용하기
-- ALTER : 오라클에 정의 되어 있는 OBJECT를 수정할때 사용하는 명령어
-- DROP : 오라클에 정의 되어 있는 OBJECT를 삭제할때 사용하는 명령어

-- 테이블에 정의 된 컬럼 추가, 수정, 삭제
--ALTER TABLE 테이블명 ADD || MODIFY || DROP 컬럼선언부(컬럼명 자료형 제약조건)
CREATE TABLE TBL_USERALTER(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(20)
 );

-- 사용자 이름 컬럼 추가 
ALTER TABLE TBL_USERALTER ADD USER_NAME VARCHAR(20);

-- 컬럼 추가할때 제약조건도 추가하기
ALTER TABLE TBL_USERALTER ADD USER_AGE NUMBER CHECK(USER_AGE>0);

INSERT INTO TBL_USERALTER VALUES(1,'ADMIN','1234','관리자',-10);
INSERT INTO TBL_USERALTER VALUES(1,'ADMIN','1234','관리자',10);
SELECT * FROM TBL_USERALTER;

-- 새로 추가되는 컬럼에 NOT NULL~ 제약조건을 설정

ALTER TABLE TBL_USERALTER ADD USER_EMAIL VARCHAR2(50) NOT NULL; 
-- 테이블은 필 수 열을 추가 하기 위해 NOT NULL 비어 있어야 합니다. 들어갈 값이 없으면 NULL

ALTER TABLE TBL_USERALTER ADD USER_EMAIL VARCHAR2(50) DEFAULT '미설정' NOT NULL; 

-- 컬럼수정하기
DESC TBL_USERALTER;
ALTER TABLE TBL_USERALTER MODIFY USER_ID VARCHAR2(10);
ALTER TABLE TBL_USERALTER MODFIY USER_PWD CHAR(10);

ALTER TABLE TBL_USERALTER MODIFY USER_NAME VARCHAR2(20) NOT NULL;

-- 컬럼삭제하기 
ALTER TABLE TBL_USERALTER DROP COLUMN USER_EMAIL;

-- 제약 조건 수정하기(추가_삭제)
-- ALTER TABLE 테이블명 ADD CONSTRAINT 제약조건명 제약조건(컬럼명)
CREATE TABLE ALTER_CONSTRAINT_TEST(
    MEMBER_NO NUMBER,
    MEMBER_ID VARCHAR2(20),
    MEMBER_PWD VARCHAR2(20)
);

SELECT * FROM ALTER_CONSTRAINT_TEST;

ALTER TABLE ALTER_CONSTRAINT_TEST ADD CONSTRAINTS PK_ALTER_CONSTRAINT_MEMBER_NO PRIMARY KEY(MEMBER_NO);

ALTER TABLE ALTER_CONSTRAINT_TEST ADD CONSTRAINTS UQ_ALTER_CONS_MEMBERID UNIQUE(MEMBER_ID);

-- NOT NULL 제약조건은 추가 하는게 아님
-- 변경하는 것
ALTER TABLE ALTER_CONSTRAINT_TES MODIFY MEMBER_ID CONSTRAINT NN_ALTER_CONS_MEMBER NOT NULL;

-- 삭제

SELECT *
FROM USER_CONSTRAINTS C
JOIN_CONS_COLUMNS CC 
USING (CONSTRAINT_NAME)
WHERE C.TABLE_NAME = 'ALTER_CONSTRAINT_TEST';

SELECT * 
FROM USER_CONSTRAINTS C
JOIN USER_CONS_COLUMNS CC
USING (CONSTRAINT_NAME)
WHERE C.TABLE_NAME = 'ALTER_CONSTRAINT_TEST';


SELECT * FROM USER_CONSTRAINTS C 
    JOIN USER_CONS_COLUMNS USING(CONSTRAINT_NAME)
WHERE C.TABLE_NAME = 'ALTER_CONSTRAINT_TEST';

-- 컬럼명,테이블 이름을 변경하기
-- 컬럼명변경하기
-- ALTER TABLE 테이블명 RENAME COLUMN 현재컬럼명 TO 변경컬럼명

ALTER TABLE ALTER_CONSTRAINT_TEST RENAME COLUMN MEMBER_NO TO USER_NO;
DESC ALTER_CONSTRAINT_TEST;

ALTER TABLE ALTER_CONSTRAINT_TEST RENAME TO ALTER_CONS_TEST;

-- 테이블을 삭제하기
-- DROP TABLE 테이블명

DROP TABLE ALTER_CONS_TEST;
DROP TABLE BASIC1;

DROP TABLE CONS_BOARD CASCADE CONSTRAINT;

-- DCL : DATA CONTROL LANGUAGE
-- 데이터베이스를 이용할 수 있는 권한 관련 명령어
-- DBA에 하는 작업
-- 권한 : 생성권한, 수정, 삽입, 삭제
-- 역할(ROLE) : 권한의 묶음
-- 권한/역할을 부여, 회수하는 명령어

-- 권한 부여하기
-- GRANT 권한명,권한명2/ROLE TO 계정명

-- 권한회수하기
--  REVOKE 권한명/ROLE명 FROM 계정명

-- 관리자 계정
SELECT * FROM BS.EMPLOYEE;
UPDATE BS.EMPLOYEE SET DEPT_CODE='D4' WHERE DEPT_CODE IS NULL;

-- 관리자 계정이 권한부여하면 접근가능해짐
GRANT SELECT ON BS.EMPLOYEE TO CHUNJAE;
GRANT SELECT ON BS.DEPARTMENT TO CHUNJAE;
GRANT INSERT ON BS.DEPARTMENT TO CHUNJAE;
GRANT CREATE TABLE, CREATE VIEW TO CHUNJAE;


REVOKE SELECT ON BS.EMPLOYEE FROM CHUNJAE;

SELECT * FROM BS.EMPLOYEE;
SELECT * FROM BS.DEPARTMENT;
INSERT INTO BS.DEPARTMENT VALUES('D0','개발부','L4');

-- ROLE을 이용해서 권한 관리하기
ALTER SESSION SET "_ORACLE_SCRIPT"=TRUE;
CREATE ROLE DEPT_ROLE;
GRANT CREATE VIEW, CREATE TABLE TO DEPT_ROLE;
GRANT DEPT_ROLE TO CHUNJAE;

SELECT * FROM DBA_SYS_PRIVS WHERE GRANTEE='DEPT_ROLE';
SELECT * FROM DBA_SYS_PRIVS WHERE GRANTEE='RESOURCE';
SELECT * FROM DBA_SYS_PRIVS WHERE GRANTEE='CONNECT';


-- TCL 트렌젝션을 제어하는 명령어
-- 트렌젝션 세션마다 관리
-- DML(INSERT,UPDATE,DELETE) 관리 하는 작업단위
CREATE TABLE TEMP_DEPT3
AS SELECT * FROM DEPARTMENT WHERE 1=0;

INSERT INTO TEMP_DEPT3 VALUES('D0','경영','L1');
SELECT * FROM TEMP_DEPT3;

COMMIT;




SELECT * FROM





-- TCL.. 트렌제션을 제어하는 멸령
-- 트랜젝션 세션마다 관의
-- DNL(INSERT,UPDATE,DELETE


















































